<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="map.js"></script>
    <style>
      html,
      body {
        height: 100%;
        font-family: "Arial Narrow Bold", sans-serif;
      }
      body {
        padding: 0;
        margin: 0;
      }
      .label-icon {
        width: 20px !important;
        height: 14px !important;
        text-align: center;
        background-color: red;
        color: white;
        font-size: 12px;
        line-height: 14px;
        font-weight: 600;
        text-shadow: #000 0 0 2px, #000 0 0 2px;
        border-radius: 2px;
      }
      .grid-icon {
        color: #fff;
      }
      .info {
        padding: 6px 8px;
        background: white;
        background: rgba(255, 255, 255, 0.8);
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        max-width: 200px;
        width: 200px;
      }
      .info h4 {
        margin: 0 0 5px;
        color: #777;
      }
      .legend {
        line-height: 18px;
        color: #555;
      }
      .legend i {
        width: 18px;
        height: 18px;
        float: left;
        margin-right: 8px;
        opacity: 0.7;
      }
      .leaflet-tooltip {
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="map" style="width: 100%; height: 100%"></div>

    <script>
      const w = 6600;
      const h = 10200;
      const mapUrl = "https://raw.githubusercontent.com/Gretta-Pendel/dw/refs/heads/master/cyberpunk/images/NightCity2045AtlasStreetNamesOnly.jpg";
      // const mapUrlPoi = "https://raw.githubusercontent.com/Gretta-Pendel/dw/refs/heads/master/cyberpunk/images/Night City 2045 Atlas Full.jpg";
      const boundsPOI = [
        [0, 0],
        [h, w],
      ];
      const bounds = [
        [0, 0],
        [h, w],
      ];
      var map = L.map("map", {
        crs: L.CRS.Simple,
        center: [0, 0],
        minZoom: -3,
        maxZoom: 1,
        //layers: [baseMaps],
      });
      // const imagePoi = L.imageOverlay(mapUrlPoi, boundsPOI).addTo(map);
      const image = L.imageOverlay(mapUrl, bounds, { opacity: 1 }).addTo(map);

      // ************** POI
      let areas = [];
      let groups = {};
      const getPOI = () => {
        poi.forEach((area) => {
          area.districts.forEach((d, i) => {
            var _districts = [];
            d.locations.forEach((l) => {
              var myIcon = L.divIcon({ className: "label-icon", html: l.label });
              const marker = L.marker([l.y, l.x], { icon: myIcon }).addTo(map);
              let desc = l.descRu ? l.desc + "<hr>" + l.descRu : l.desc;
              let name = l.nameRu ? l.name + " | " + l.nameRu : l.name;
              marker.bindTooltip(name).openTooltip();
              marker.bindPopup(desc).openPopup();
              _districts.push(marker);
            });
            let districtGroup = L.layerGroup(_districts);
            groups["<b>" + d.letter + "</b> " + d.district] = districtGroup;
            districtGroup.addTo(map);
          });
        });
      };
      getPOI();
      var layerControl = L.control.layers(null, groups).addTo(map);
      // ************** end POI

      // tiles

      var tiles = L.tileLayer(mapUrl, {
        maxZoom: 3,
      }).addTo(map);
      function style(feature) {
        return {
          weight: 0,
          fillOpacity: 0,
        };
      }
      function highlightFeature(e) {
        var layer = e.target;
        layer.setStyle({
          fillColor: "white",
          fillOpacity: 0.3,
        });
        layer.bringToFront();
        info.update(layer.feature.properties);
      }
      function resetHighlight(e) {
        geojson.resetStyle(e.target);
        info.update();
      }
      function zoomToFeature(e) {
        map.fitBounds(e.target.getBounds());
      }
      var areasData = { type: "FeatureCollection", features: [] };
      var emptyG = {
        type: "Polygon",
        coordinates: [
          [
            [4096.5, 4651],
            [4381.5, 4481.5],
          ],
        ],
      };
      poi.forEach((area, index) => {
        let _area = {
          type: "Feature",
          id: "area_" + index,
          properties: {
            name: area.area,
            desc: area.areaDesc,
          },
          geometry: !area.geometry || Object.keys(area.geometry).length === 0 ? emptyG : area.geometry,
        };
        areasData.features.push(_area);
        area.districts.forEach((district) => {
          let _district = {
            type: "Feature",
            id: "district_" + district.letter,
            properties: {
              name: district.district,
              desc: district.districtDesc,
              gangs: district.gangsPresent,
            },
            geometry: !district.geometry || Object.keys(district.geometry).length === 0 ? emptyG : district.geometry,
          };
          areasData.features.push(_district);
        });
      });

      L.geoJson(areasData, { style: style }).addTo(map);
      function onEachFeature(feature, layer) {
        layer.on({
          mouseover: highlightFeature,
          mouseout: resetHighlight,
          click: zoomToFeature,
        });
      }
      geojson = L.geoJson(areasData, {
        style: style,
        onEachFeature: onEachFeature,
      }).addTo(map);

      var info = L.control();
      info.onAdd = function (map) {
        this._div = L.DomUtil.create("div", "info"); // create a div.info
        this.update();
        return this._div;
      };
      // method that we will use to update the control based on feature properties passed
      info.update = function (props) {
        let gangs = "";
        if (props && props.gangs && props.gangs.length) {
          props.gangs.forEach((g) => {
            gangs += g + ", ";
          });
          gangs = gangs.substring(0, gangs.length - 2);
        }
        let text = !props ? "Hover over an area" : `<b>${props.name}</b><br>${props.desc}<br><b>Gangs</b>: ${gangs}`;
        this._div.innerHTML = "<h4>Districts</h4>" + text;
      };
      info.addTo(map);

      var legend = L.control({ position: "bottomright" });
      legend.onAdd = function (map) {
        var div = L.DomUtil.create("div", "info legend");
        // loop through our density intervals and generate a label with a colored square for each interval
        div.innerHTML += "";
        return div;
      };
      legend.addTo(map);

      // ************** end tiles

      // Устанавливаем границы карты (соответствуют изображению)
      map.fitBounds(boundsPOI);
      // map.fitBounds(bounds);
    </script>
  </body>
</html>
